{"version":3,"file":"use-vega.cjs.production.min.js","sources":["../src/enums/GrammerType.ts","../src/helpers/view.ts","../src/hooks/useRefState.ts","../src/useVega.tsx"],"sourcesContent":["export enum GrammerType {\n  VEGA = 'vega',\n  VEGA_LITE = 'vega-lite',\n}\n","import {\n  View,\n  parse as vegaParse,\n  Config,\n  // Config,\n  // Spec\n} from 'vega'\nimport { compile as vlCompile, TopLevelSpec } from 'vega-lite'\nimport vegaTooltip from 'vega-tooltip'\nimport { MutableRefObject } from 'react'\nimport { GrammerType } from '../enums/GrammerType'\n// import invariant from 'tiny-invariant'\nconst DEFAULT_OPTIONS: ViewOptions = {\n  hover: true,\n  renderer: 'canvas',\n}\n\nexport type ViewOptions = ConstructorParameters<typeof View>[1]\n\nexport const updateVegaView = (\n  viewReference: MutableRefObject<HTMLDivElement | null>,\n  vlSpec?: TopLevelSpec,\n  /*vegaSpec?: Spec, vegaConfig: Config = {},*/ overrideOptions: ViewOptions = {},\n  grammer: GrammerType = GrammerType.VEGA_LITE\n) => {\n  if (!viewReference || !viewReference.current || !vlSpec) return\n  const opts: ViewOptions = {\n    ...DEFAULT_OPTIONS,\n    ...overrideOptions,\n    container: viewReference.current,\n  }\n  // vegaParse()\n  // const spec = vlSpec ? vlCompile(vlSpec).spec : vegaSpec\n  const spec =\n    grammer === GrammerType.VEGA_LITE ? vlCompile(vlSpec).spec : vlSpec\n  // invariant(!spec, 'Vega lite or vega spec must be defined')\n  // const config = vlSpec ? vlSpec.config : vegaConfig\n  // @ts-ignore\n  const runtime = vegaParse(spec, vlSpec.config as Config)\n  const view = new View(runtime, opts)\n  vegaTooltip(view)\n  return view\n}\n","import {\n  Dispatch,\n  MutableRefObject,\n  SetStateAction,\n  useCallback,\n  useRef,\n  useState,\n} from 'react'\n\nconst useRefState = <S>(\n  initialState: S | (() => S)\n): [MutableRefObject<S>, Dispatch<SetStateAction<S>>] => {\n  const [firstState, _setState] = useState<S>(initialState)\n  const latestState = useRef<S>(firstState)\n  const setState = useCallback((nextState) => {\n    latestState.current = nextState\n    _setState(nextState)\n  }, [])\n  return [latestState, setState]\n}\n\nexport default useRefState\n","import { useRef, useEffect, useCallback, useState } from 'react'\nimport { TopLevelSpec } from 'vega-lite'\nimport { Spec, UrlData, View } from 'vega'\nimport { updateVegaView, ViewOptions } from './helpers/view'\nimport useRefState from './hooks/useRefState'\nimport warning from 'tiny-warning'\nimport { InlineData, NamedData } from 'vega-lite/build/src/data'\nimport { GrammerType } from './enums/GrammerType'\n// import useForceUpdate from './hooks/useForceUpdate'\n\nconst isView = (view: View | null | undefined): view is View => {\n  return !!view && !!view?.addDataListener\n}\nconst safeUpdateView = (\n  visualization: React.MutableRefObject<View | null | undefined>,\n  ref: React.MutableRefObject<HTMLDivElement | null>,\n  spec: TopLevelSpec,\n  opts: ViewOptions = {},\n  grammer?: GrammerType\n) => {\n  let view: View | undefined = undefined\n  try {\n    view = updateVegaView(ref, spec, opts, grammer)\n  } catch (err) {\n    warning(true, err)\n    return err\n  }\n  if (isView(view)) {\n    visualization.current = view\n    return false\n  }\n  return new Error('Could not load view')\n}\n\nexport interface UseVegaOptions {\n  overrides?: ViewOptions\n  grammer?: GrammerType\n}\n\nconst validateData = (spec: Spec | TopLevelSpec) => {\n  return !!(\n    (spec.data && (spec.data as UrlData).url) ||\n    (!Array.isArray(spec?.data) && (spec?.data as InlineData).values) ||\n    (Array.isArray(spec?.data) &&\n      spec?.data.length > 0 &&\n      (spec?.data[0] as NamedData).name)\n  )\n}\nexport const useVega = (\n  initialSpec: TopLevelSpec | Spec,\n  opts?: UseVegaOptions\n) => {\n  const [vegaWrapperRef, setWrapperRef] = useRefState<HTMLDivElement | null>(\n    null\n  )\n  const currentSpec = useRef(initialSpec)\n  const visualization = useRef<View | undefined | null>(null)\n  // const forceUpdate = useForceUpdate()\n  const [isLoading, setLoading] = useRefState(true)\n  const [noData, setNoData] = useRefState(false)\n  const [error, setError] = useState(null)\n  const updateView = useCallback(\n    (spec) => {\n      if (!vegaWrapperRef) {\n        return\n      }\n      if (visualization.current) {\n        visualization.current.finalize()\n        visualization.current = null\n      }\n      const isValid = validateData(spec)\n      if (!isValid) {\n        setNoData(true)\n      } else {\n        const error = safeUpdateView(\n          visualization,\n          vegaWrapperRef,\n          spec,\n          opts ? opts.overrides : {},\n          opts?.grammer || GrammerType.VEGA_LITE\n        )\n        if (!error) {\n          setNoData(false)\n          setError(null)\n        } else {\n          setError(error)\n        }\n      }\n      setLoading(false)\n    },\n    [setLoading, vegaWrapperRef, opts, setNoData]\n  )\n\n  const updateContainer = useCallback(\n    (elementRef: HTMLDivElement) => {\n      if (!elementRef) {\n        return\n      }\n      setWrapperRef(elementRef)\n    },\n    [setWrapperRef]\n  )\n\n  useEffect(() => {\n    if (!vegaWrapperRef.current) {\n      return\n    }\n    updateView(currentSpec.current || initialSpec)\n    return () => {\n      if (visualization.current) {\n        visualization.current.finalize()\n      }\n    }\n  }, [vegaWrapperRef, initialSpec, updateView])\n\n  return {\n    ref: vegaWrapperRef,\n    view: visualization,\n    updateView,\n    isLoading: isLoading.current,\n    noData: noData.current,\n    error,\n    updateContainer,\n  }\n}\n"],"names":["GrammerType","DEFAULT_OPTIONS","hover","renderer","useRefState","initialState","useState","_setState","latestState","useRef","setState","useCallback","nextState","current","initialSpec","opts","vegaWrapperRef","setWrapperRef","currentSpec","visualization","isLoading","setLoading","noData","setNoData","error","setError","updateView","spec","finalize","data","url","Array","isArray","values","length","name","validateData","ref","grammer","view","undefined","viewReference","vlSpec","overrideOptions","VEGA_LITE","container","vlCompile","runtime","vegaParse","config","View","vegaTooltip","updateVegaView","err","addDataListener","isView","Error","safeUpdateView","overrides","updateContainer","elementRef","useEffect"],"mappings":"0EAAYA,kXAAZ,SAAYA,GACVA,cACAA,wBAFF,CAAYA,IAAAA,OCYZ,IAAMC,EAA+B,CACnCC,OAAO,EACPC,SAAU,UCLNC,EAAc,SAClBC,SAEgCC,WAAYD,GAAzBE,OACbC,EAAcC,eACdC,EAAWC,eAAY,SAACC,GAC5BJ,EAAYK,QAAUD,EACtBL,EAAUK,KACT,UACI,CAACJ,EAAaE,oBC8BA,SACrBI,EACAC,SAEwCX,EACtC,MADKY,OAAgBC,OAGjBC,EAAcT,SAAOK,GACrBK,EAAgBV,SAAgC,QAEtBL,GAAY,GAArCgB,OAAWC,SACUjB,GAAY,GAAjCkB,OAAQC,SACWjB,WAAS,MAA5BkB,OAAOC,OACRC,EAAaf,eACjB,SAACgB,MACMX,MAGDG,EAAcN,UAChBM,EAAcN,QAAQe,WACtBT,EAAcN,QAAU,MA7BX,SAACc,YAEjBA,EAAKE,MAASF,EAAKE,KAAiBC,MACnCC,MAAMC,cAAQL,SAAAA,EAAME,cAAUF,SAAAA,EAAME,KAAoBI,SACzDF,MAAMC,cAAQL,SAAAA,EAAME,cACnBF,SAAAA,EAAME,KAAKK,QAAS,UACnBP,SAAAA,EAAME,KAAK,GAAiBM,OAyBbC,CAAaT,GAGtB,KACCH,EA7DS,SACrBL,EACAkB,EACAV,EACAZ,EACAuB,YADAvB,IAAAA,EAAoB,QAGhBwB,OAAyBC,MAE3BD,EFH0B,SAC5BE,EACAC,EAC8CC,EAC9CL,eAD8CK,IAAAA,EAA+B,aAC7EL,IAAAA,EAAuBtC,EAAY4C,WAE9BH,GAAkBA,EAAc5B,SAAY6B,OAC3C3B,OACDd,EACA0C,GACHE,UAAWJ,EAAc5B,UAIrBc,EACJW,IAAYtC,EAAY4C,UAAYE,UAAUJ,GAAQf,KAAOe,EAIzDK,EAAUC,QAAUrB,EAAMe,EAAOO,QACjCV,EAAO,IAAIW,OAAKH,EAAShC,UAC/BoC,EAAYZ,GACLA,GEnBEa,CAAef,EAAKV,EAAMZ,EAAMuB,GACvC,MAAOe,UAEAA,SAfI,SAACd,WACLA,YAAUA,SAAAA,EAAMe,iBAgBrBC,CAAOhB,IACTpB,EAAcN,QAAU0B,GACjB,GAEF,IAAIiB,MAAM,uBA2CGC,CACZtC,EACAH,EACAW,EACAZ,EAAOA,EAAK2C,UAAY,UACxB3C,SAAAA,EAAMuB,UAAWtC,EAAY4C,WAE1BpB,EAIHC,EAASD,IAHTD,GAAU,GACVE,EAAS,YAXXF,GAAU,GAgBZF,GAAW,MAEb,CAACA,EAAYL,EAAgBD,EAAMQ,IAG/BoC,EAAkBhD,eACtB,SAACiD,GACMA,GAGL3C,EAAc2C,KAEhB,CAAC3C,WAGH4C,aAAU,cACH7C,EAAeH,eAGpBa,EAAWR,EAAYL,SAAWC,GAC3B,WACDK,EAAcN,SAChBM,EAAcN,QAAQe,cAGzB,CAACZ,EAAgBF,EAAaY,IAE1B,CACLW,IAAKrB,EACLuB,KAAMpB,EACNO,WAAAA,EACAN,UAAWA,EAAUP,QACrBS,OAAQA,EAAOT,QACfW,MAAAA,EACAmC,gBAAAA"}